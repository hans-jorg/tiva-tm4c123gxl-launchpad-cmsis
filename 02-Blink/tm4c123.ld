/**
 * @file     tm4c123.ld
 * @brief    Linker script according CMSIS
 * @version  V1.0
 * @date     23/01/2016
 *
 * @note     The blinking frequency depends on core frequency
 * @note     Direct access to registers
 * @note     CMSIS library used
 *
 *
 * Configuration for LM4F120H5QR / Tiva TM4C123GH6PM
 * FLASH: start address 0x00       length 0x40000 (256 KB)
 * SRAM:  start address 0x20000000 length 0x8000  (32 KB)
 */

MEMORY
{
    FLASH (rx)  : ORIGIN = 0x00000000, LENGTH = 0x00040000
    RAM (rwx)   : ORIGIN = 0x20000000, LENGTH = 0x00007000
}

ENTRY(Reset_Handler)

/*
 * Sections for C (there are more for C++)
 * .text  - instructions
 * .rodata- constants
 * .data  - initializaed data
 * .bss   - non initialized data
 * .stack - pointer to highest address in RAM (aligned)
 */

SECTIONS
{
    /*
     * TEXT : Code and constants
     * Interrupt table must be stored starting at address 0 of Flash
     * Address 0: initial value of SP
     * Address 1: initial value of PC -> Reset_Handler
     *
     * See Table 2-8: Exception Types
     */

    _text_start = .;            /* start of flash (=0)                     */
    _text = .;

    .text :
    {
            KEEP(*(.nvictable)) /* table must be first                      */
            *(.text*)           /* instructions follow                      */
            . = ALIGN(4);
            *(.rodata*)         /* constants follow                         */
    } > FLASH                   /* all stored int flash memory              */

    /*
    * ARM.ex{tab,idx} :
    * Information to unwindle the stack
    * See -funwind-tables or -fexceptions flag in ld
    *
    */
    .ARM.extab :
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
    } > FLASH

    _exidx_start = .;
    .ARM.exidx :
    {
        *(.ARM.exidx* .gnu.linkonce.armexidx.*)
    } > FLASH
    _exidx_end = .;

    /*
     * End of text section
     */
    /*. = ALIGN(0x100);   /* Align to a 256 byte boundary for debugging    */
    _text_end = .;        /* its address is the end of code section        */
    _etext   = .;
    /*
     * DATA : Initialized data
     * Initialized data must be in RAM, but initial contents must be in flash
     * and copied to RAM by initialization procedure
     */
    .data : AT (_etext)        /* store a copy in flash                    */
    {
            . = ALIGN(4);
            _data_start = .;    /* start of data area in RAM                */
            *(.data*)           /* initialized data                         */
            *(vtable*)          /* vtables are generated by C++             */
            _data_end = .;      /* its address is the end of data section   */
    } > RAM

    /*
     * BSS : Block Started by Symbol (Non initialized data)
     * Non initialized data must be in RAM and zeroed by initialziation
     * procedure
     */
    .bss :
    {
            . = ALIGN(4);
            _bss_start = .;     /* start of bss area in RAM                 */
            *(.bss*)            /* non initialized data                     */
            . = ALIGN(4);
            *(COMMON*)          /* etc                                      */
            . = ALIGN(4);
            _bss_end = .;       /* its address is the end of bss section    */
    } > RAM

    /*
     * HEAP : Heap Section (non initialized data)
     * Non initialized data must be in RAM and zeroed by initialziation
     * procedure
     */
    Heap_Mem = .;

    .heap (COPY):
    {
        _end = .;
/*        PROVIDE(end = .); */
        *(.heap*)
        _HeapLimit = .;
    } > RAM

    /*
     * STACK : Stack definition
     * Only the initial value of SP must be defined and stored in address 0
     * of flash memory in the interrupt vector table
     */
    .stack_dummy :
    {
        . = ALIGN(4);
        *(.stack*);             /* No symbols                               */
    } > RAM

    /* Set stack top to end of RAM */
    _StackTop = ORIGIN(RAM) + LENGTH(RAM);
    /* Set stack limit move down by size of stack_dummy section */
    _StackLimit = _StackTop - SIZEOF(.stack_dummy);
    PROVIDE(_stack = _StackTop);

    /* Check if data + heap + stack exceeds RAM limit */
    ASSERT(_StackLimit >= _HeapLimit, "region RAM overflowed with stack")

}
